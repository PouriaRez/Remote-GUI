#!/usr/bin/env python3
"""
Refresh Frontend APIs Script

This script automatically generates frontend API functions that match the backend implementation.
It scans the backend plugin routers and creates corresponding frontend API files.

Usage:
    python refresh_frontend_apis.py <plugin_name>
    python refresh_frontend_apis.py all

Examples:
    python refresh_frontend_apis.py calculator
    python refresh_frontend_apis.py taskmanager
    python refresh_frontend_apis.py all
"""

import os
import sys
import ast
import inspect
from pathlib import Path
from typing import Dict, List, Any, Optional
import argparse

# Add the backend directory to the path so we can import the plugins
backend_dir = Path(__file__).parent.parent
sys.path.insert(0, str(backend_dir))

def get_plugin_routes(plugin_name: str) -> List[Dict[str, Any]]:
    """
    Scan a plugin's router file and extract route information using regex.
    """
    plugin_dir = backend_dir / "plugins" / plugin_name
    router_file = plugin_dir / f"{plugin_name}_router.py"
    
    if not router_file.exists():
        print(f"âŒ Plugin '{plugin_name}' not found: {router_file}")
        return []
    
    routes = []
    
    try:
        # Read the router file
        with open(router_file, 'r') as f:
            content = f.read()
        
        import re
        
        # Find all route decorators using regex
        # Pattern: @api_router.method("path")
        pattern = r'@api_router\.(get|post|put|delete|patch)\("([^"]+)"\)\s*\n\s*async def (\w+)\(([^)]*)\):'
        
        matches = re.findall(pattern, content, re.MULTILINE)
        
        for match in matches:
            method = match[0].upper()
            path = match[1]
            function_name = match[2]
            params_str = match[3]
            
            # Parse parameters
            params = []
            if params_str.strip():
                # Split by comma and clean up
                param_list = [p.strip() for p in params_str.split(',')]
                for param in param_list:
                    # Extract parameter name (before any type hints or defaults)
                    param_name = param.split(':')[0].split('=')[0].strip()
                    if param_name and param_name != 'self':
                        params.append(param_name)
            
            # Find the docstring for this function
            docstring = ""
            # Look for the function definition and extract docstring
            func_pattern = rf'async def {function_name}\([^)]*\):\s*\n\s*"""(.*?)"""'
            doc_match = re.search(func_pattern, content, re.DOTALL)
            if doc_match:
                docstring = doc_match.group(1).strip()
            
            routes.append({
                'method': method,
                'path': path,
                'function_name': function_name,
                'parameters': params,
                'docstring': docstring
            })
        
        print(f"âœ… Found {len(routes)} routes in {plugin_name}")
        for route in routes:
            print(f"   - {route['method']} {route['path']} -> {route['function_name']}")
        return routes
        
    except Exception as e:
        print(f"âŒ Error parsing {plugin_name}: {e}")
        return []

def generate_frontend_api_file(plugin_name: str, routes: List[Dict[str, Any]]) -> str:
    """
    Generate the frontend API file content.
    """
    api_url = "window._env_?.REACT_APP_API_URL || \"http://localhost:8000\""
    
    content = f"""// Auto-generated API functions for {plugin_name} plugin
// Generated by refresh_frontend_apis.py
// Do not edit this file manually - it will be overwritten

const API_URL = {api_url};

/**
 * {plugin_name.title()} Plugin API Functions
 * Auto-generated from backend implementation
 */

"""
    
    for route in routes:
        method = route['method']
        path = route['path']
        function_name = route['function_name']
        parameters = route['parameters']
        docstring = route['docstring']
        
        # Generate function name (convert snake_case to camelCase)
        api_function_name = function_name.replace('_', ' ').title().replace(' ', '')
        api_function_name = api_function_name[0].lower() + api_function_name[1:]
        
        # Generate parameters string
        param_str = ', '.join(parameters) if parameters else ''
        
        # Generate the function
        content += f"""/**
 * {docstring or f'{method} {path}'}
 */
export const {api_function_name} = async ({param_str}) => {{
  try {{
    const url = `${{API_URL}}/{plugin_name}{path}`
"""
        
        if method == 'GET':
            content += f"""    const response = await fetch(url);
    if (!response.ok) {{
      throw new Error(`HTTP error! status: ${{response.status}}`);
    }}
    return await response.json();
"""
        else:
            # For POST, PUT, DELETE, etc.
            if parameters:
                # Find the main data parameter (usually the first one that's not a path parameter)
                data_param = None
                for param in parameters:
                    if param not in path:  # Not a path parameter
                        data_param = param
                        break
                
                if data_param:
                    content += f"""    const response = await fetch(url, {{
      method: '{method}',
      headers: {{
        'Content-Type': 'application/json',
      }},
      body: JSON.stringify({data_param})
    }});
"""
                else:
                    content += f"""    const response = await fetch(url, {{
      method: '{method}',
      headers: {{
        'Content-Type': 'application/json',
      }}
    }});
"""
            else:
                content += f"""    const response = await fetch(url, {{
      method: '{method}',
      headers: {{
        'Content-Type': 'application/json',
      }}
    }});
"""
            
            content += f"""    if (!response.ok) {{
      const errorData = await response.json().catch(() => ({{}}));
      throw new Error(errorData.detail || `HTTP error! status: ${{response.status}}`);
    }}
    return await response.json();
"""
        
        content += f"""  }} catch (error) {{
    console.error('Error calling {api_function_name}:', error);
    throw error;
  }}
}};

"""
    
    # Add a default export with all functions
    function_names = [route['function_name'].replace('_', ' ').title().replace(' ', '') for route in routes]
    function_names = [name[0].lower() + name[1:] for name in function_names]
    
    content += f"""
// Default export with all functions
export default {{
{', '.join(function_names)}
}};
"""
    
    return content

def refresh_plugin_apis(plugin_name: str) -> bool:
    """
    Refresh the frontend APIs for a specific plugin.
    """
    print(f"ğŸ”„ Refreshing frontend APIs for '{plugin_name}'...")
    
    # Get routes from backend
    routes = get_plugin_routes(plugin_name)
    if not routes:
        return False
    
    # Generate frontend API file content
    api_content = generate_frontend_api_file(plugin_name, routes)
    
    # Write to frontend directory
    frontend_dir = Path(__file__).parent.parent.parent / "local-cli-fe-full" / "src" / "plugins" / plugin_name
    frontend_dir.mkdir(parents=True, exist_ok=True)
    
    api_file = frontend_dir / f"{plugin_name}_api.js"
    
    try:
        with open(api_file, 'w') as f:
            f.write(api_content)
        
        print(f"âœ… Generated {api_file}")
        print(f"   - {len(routes)} API functions created")
        return True
        
    except Exception as e:
        print(f"âŒ Error writing {api_file}: {e}")
        return False

def refresh_all_plugins():
    """
    Refresh frontend APIs for all plugins.
    """
    plugins_dir = backend_dir / "plugins"
    
    if not plugins_dir.exists():
        print(f"âŒ Plugins directory not found: {plugins_dir}")
        return
    
    plugin_names = []
    for item in plugins_dir.iterdir():
        if item.is_dir() and not item.name.startswith('_'):
            plugin_names.append(item.name)
    
    if not plugin_names:
        print("âŒ No plugins found")
        return
    
    print(f"ğŸ”„ Refreshing frontend APIs for {len(plugin_names)} plugins...")
    
    success_count = 0
    for plugin_name in plugin_names:
        if refresh_plugin_apis(plugin_name):
            success_count += 1
        print()  # Add spacing between plugins
    
    print(f"ğŸ‰ Successfully refreshed {success_count}/{len(plugin_names)} plugins!")

def main():
    parser = argparse.ArgumentParser(description='Refresh frontend API functions from backend plugins')
    parser.add_argument('plugin', help='Plugin name to refresh, or "all" to refresh all plugins')
    
    args = parser.parse_args()
    
    print("ğŸš€ Frontend API Refresh Tool")
    print("=" * 40)
    
    if args.plugin.lower() == 'all':
        refresh_all_plugins()
    else:
        if refresh_plugin_apis(args.plugin):
            print(f"ğŸ‰ Successfully refreshed '{args.plugin}' plugin!")
        else:
            print(f"âŒ Failed to refresh '{args.plugin}' plugin")
            sys.exit(1)

if __name__ == "__main__":
    main()
